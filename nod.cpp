Задача №9.
Найти наибольший общий делитель чисел m и n(количество знаков в числах не меньше 15).




#include <iostream> // для использования cin, cout и некоторых других функций
#include <string>	// для использования строк


using namespace std;

string divider[9];
// в нем будет хранится значения делитиля умноженное на (i+1). 
// Это ускорит поиск числа для вычитания при делении, вместо того, чтобы каждый раз умножать делитель и проверять, можно ли его вычесть.

string revers(string a)
{
	// возвращает реверс числа
	// проходим циклом до середины меняя противолежащие значения местами
	for (int i = 0; i < a.length() / 2; i++) swap(a[i], a[a.length() - i - 1]);
	return a;
}
short cmp(string a, string b)
{
	// сравнение двух длинных чисел

	//  1 = a > b
	//  0 = a = b
	// -1 = a < b

	if (a.length() > b.length()) return 1;
	else if (a.length() < b.length()) return -1;
	else
	{
		for (int i = a.length() - 1; i >= 0; i--)			// перебираем значения индексов строк до тех пор, пока один из индексов не окажется больше другого
		{
			if (a[i] > b[i]) return 1;
			else if (a[i] < b[i]) return -1;
			else continue;
		}
		return 0;
	}
}
string sum(string a, string b)
{
	// сложение a и b

	bool flag = false; // флаг нам будет говорить о том, что a[i] + b[i] > 9. 

	if (a.length() < b.length()) swap(a, b);
	// чтобы не дублировать код, просто будем сохранять значения суммы сразу в одну переменную. 
	// Я посчитал, что проще сохранять значение суммы в переменную с длинной большей или равной длине второй
	// Поэтому если длина a меньеше длины b, то я поменяю местами значения a и b 

	for (int i = 0; i < b.length(); i++) //проходимся по двум строкам. Идем по длине b, которая меньше или равна длине a. По оставшейся части a пройдемся позже
	{
		int n = a[i] - '0' + b[i] - '0'; // складываем a[i] и b[i]
										 // a[i] - ASCII код (int)

		if (flag) // если при сложении приедыдущего десятка мы получили число больше 9, то к этому десятку прибавим 1. Уберем флаг
		{
			n++;
			flag = false;
		}

		if (n > 9) // если n>9, то уменьшим его на 10, переведем значение в char и запишим в a[i].
		{
			a[i] = n - 10 + '0';
			flag = true;
		}
		else a[i] = n + '0'; // если n<9, то просто переведем значение в char и запишем в a[i]
	}

	for (int i = b.length(); flag && i < a.length(); i++)
		// если после прибавленяи b к a у нас все еще поднят флаг, то будем добавлять 1 к последующим десяткам пока поднят флаг или пока не дойдем до конца a
	{
		if (a[i] < '9')
		{
			a[i]++;
			flag = false;
		}
		else
		{
			a[i] = '0';
		}
	}

	if (flag) a += "1"; // если и после прохода флаг остался, то добавляем 1 в конец строки

	return a;
}
string sub(string a, string b)
{
	// вычитание из a b
	// при вызове этой функции мы рассматриваем только ситуацию, когда a>=b. Отрицательные числа нам не понадобятся.

	bool flag = false; // флаг нам будет говорить о том, что a[i] + b[i] < 0.

	for (int i = 0; i < b.length(); i++)  //проходимся по двум строкам. Идем по длине b, которая меньше или равна длине a. По оставшейся части a пройдемся позже
	{
		int n = a[i] - '0' - b[i] + '0'; // вычитаем из a[i] b[i]. На самом деле -'0' и +'0' можно убрать так как они самоуничтожаются, но для нагладности оставил 

		if (flag) // если при вычитании предыдущих десятков мы получили число меньше 0, то из разности этих десятков мы дополнительно вычтим еденицу
		{
			n--;
			flag = false;
		}

		if (n < 0) // если разность меньше 0, то увеличим ее на 10, переведем значение в char и запишем в a[i].
		{
			a[i] = n + 10 + '0';
			flag = true;
		}
		else a[i] = n + '0'; // если n>0, тогда просто переведем значение в char и запишем его в a[i]
	}

	for (int i = b.length(); flag && i < a.length(); i++)
		// если после вычитания из a b у нас все еще поднят флаг, то будем вычитать 1 из последующих десятков пока поднят флаг или пока не дойдем до конца a
	{
		if (a[i] > '0')
		{
			a[i]--;
			flag = false;
		}
		else
		{
			a[i] = '9';
		}
	}

	for (int i = a.length() - 1; a[i] == '0' && a.length() > 1; i--) a.erase(a.length() - 1, 1);
	// после всех вычитаний у нас могли остаться незначащие нули.

	return a;
}
string mod(string a, string b)
{
	// получение остатка от деления a на b
	// остаток хранится в a

	string dividend; // делимое 
	divider[0] = b;  // делитель
	for (int i = 1; i < 9; i++) divider[i] = sum(divider[i - 1], b);
	// заполним массив делителя. Суть заполнения описана выше при инициализации
	// так-то можно было инициализировать и тут, так как он используется только здесь, 
	// но тогда следовало бы и удалять его после каждого выполнения этой функции, так как иначе эти массивы так бы и висели в оперативке и занимали пространство в памяти

	do
	{
		// тут выполняем деление столбиком.
		// берем часть делимого (divident) длинной делителя, если делитель больше ( а это можно понять уже сравнив первые десятки ),
		// то добавляем еще один символ к делимому ( тогда уж оно точно будет больше )
		if (a[a.length() - 1] - '0' >= b[b.length() - 1] - '0')
		{
			dividend = a.substr(a.length() - b.length(), b.length());
			a.erase(a.length() - b.length(), b.length());
		}
		else
		{
			dividend = a.substr(a.length() - b.length() - 1, b.length() + 1);
			a.erase(a.length() - b.length() - 1, b.length() + 1);
		}

		// выбор на какой делитель из списка мы будем делить divident
		// цикл крутится пока не найден такой делитель, на который можно поделить divident, но при этом на следующий делитель нельзя 
		int i = 0;
		bool flag = true;
		while (flag && i < 8)
		{
			if (cmp(dividend, divider[i]) >= 0 && cmp(dividend, divider[i + 1]) == -1) flag = false;
			else i++;
		}
		dividend = sub(dividend, divider[i]); // вычитаем из divident делитель, для получения остатка

		if (dividend.length() != 1 || dividend[0] != '0') a.insert(a.length(), dividend, 0, dividend.length()); // если остаток не ноль, то припишем остаток вначало делимого

		if (a == "") a = "0"; // если после всех делений остаток пустой, то делитель делится нацело на делимое 
		if (cmp(a, b) == -1) break; // если остаток от деления a меньше делителя b то деление окончено и можно выыходить
	} while (true);

	return a;
}
bool num_check(string a)
{
	// проверка на неправильный ввод
	// если число введено верно, то вернется значение true

	if (a[0] == '0') return false; // первый символ не ноль 
	for (int i = 1; i < a.length(); i++) if (a[i]<'0' || a[i]>'9') return false; // в числе должны быть только значения от 0 до 9

	return true;
}

void main()
{
	// подключение русского языка
	setlocale(LC_ALL, "Russian");
	setlocale(LC_ALL, " ");

	string a; // первое число
	string b; // второе число

	bool mst; // флаг ошибки ввода
	do
	{
		cout << "Введите первое число:\n";
		cin >> a;
		cout << "Введите второе число:\n";
		cin >> b;
		// допускается, что вначале числа может быть один минус или плюс. Он никак не повлияет на подсчет НОД
		if (a[0] == '+' || a[0] == '-') a.erase(0, 1);
		if (b[0] == '+' || b[0] == '-') b.erase(0, 1);
		if (!num_check(a) || !num_check(b)) // если одно из чисел введено не верно, то выдаст ошибку 
		{
			cout << "\nОшибка ввода чисел. Повторите попытку\n\n";
			mst = true;
		}
		else mst = false;
	} while (mst);

	a = revers(a); // далее все вычисления будут проводится с перевернутыми числами. Так просто проще
	b = revers(b);

	// Алгоритм Евклида - нахождение наибольшего общего делителя
	// https://younglinux.info/algorithm/euclidean

	bool flag = true;
	do
	{
		short cmp_ans = cmp(a, b);
		if (cmp_ans == 0)
		{
			cout << "\nНОД первого и второго числа:\n" << revers(a) << "\n\n";
			flag = false;
		}
		else if (cmp_ans == 1) a = mod(a, b);
		else b = mod(b, a);

		if (a == "0")
		{
			cout << "\nНОД первого и второго числа:\n" << revers(b) << "\n\n";
			flag = false;
		}
		else if (b == "0")
		{
			cout << "\nНОД первого и второго числа:\n" << revers(a) << "\n\n";
			flag = false;
		}

	} while (flag);

	system("pause");
}